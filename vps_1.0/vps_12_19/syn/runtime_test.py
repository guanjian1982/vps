#!/usr/bin/python2.7
#-----------------------------------------------------------
#-- Automatically generated by Reddiag --
#-- Veloce Prototyping System version: 2022.12
#-- Veloce Prototyping System build: 5461546
#-- Time: Thu Dec  7 19:42:13 2023
#-----------------------------------------------------------



import json, os, re, sys, shutil, argparse
from shutil import copyfile

class ReddiagRTException(Exception):
    pass

class ReddiagRuntimeTests:

    tracks_json_path = ""
    redrun_log_path = ""
    redrun_log = ""
    from_fpga = ""
    to_fpga = ""
    tracks_data = None
    hex_pattern = re.compile(r"0x[0-9a-fA-F]{8}")
    gvalue_start_tag = "__GVALUE_SECTION_START__"
    gvalue_end_tag = "__GVALUE_SECTION_END__"
    pmux_start_tag = "__PMUX_SECTION_START__"
    pmux_end_tag = "__PMUX_SECTION_END__"
    gvalue_section = ""
    pmux_section = ""
    pmux_warning = "Pinmux is not enabled for this design"
    reddiag_reports_folder = "track_status"
    runtime_folder = ""
    dont_use_tracks_folder = "dont_use_tracks"
    track_summary = "summary.rpt"
    out_dir = ""
    compile_dir = ""
    track_nets_dict = {} # net_name: {value: v, size:s}
    pinmux_dict = {} # track_name : {crc_error : v, rx_lock_status:v, serdes_lock_status:v}
    gnets_to_fpga_dict = {} # fpga_name : {comare:net,testing: net, compare_n: net, testing_n:net}
    header_sizes_dict = {}
    suggestion_dict = {}
    sub_sections = []
    serdes_locks_count = 0
    rx_locks_count = 0
    crc_errors_count = 0
    all_fpgas_set = set()
    cmp_failed_fpga = set()
    serdes_failed_fpga = set()
    rx_failed_fpga = set()
    crc_failed_fpga = set()
    error_counter = 0
    errors_indexes = {}
    global_errors = set()
    track_errors_dict = {
        "hw_track_issue"            : "HW tracks issue. Please source ./dont_use_tracks.rdc (or ./dont_use_tracks.tcl) in your VPS run to omit\n\
            the failing track(s).\n",
        "hw_track_issue_no_mux"     : "A FAIL comparison status on a track with no PINMUX can be interpreted as follows:\n\
            1 - A failing HW track. Please source ./dont_use_tracks.rdc (or ./dont_use_tracks.tcl) in your VPS run using to omit it.\n\
            2 - A timing violation or a DUT clock frequency too high. Try relaxing the timing constraints using the synthesis tool or\n\
                choose a lower clock frequency.\n",
        "normal_error"              : "This can occur due to timing violations or to a DUT clock frequency too high. Try relaxing the timing\n\
            constraints using the synthesis tool or choose a clock frequency that is equal or lower than the clock frequency computed by wrap.\n",
        "normal_error_corrected"    : "CRC and COMPARE status are captured on different RESET events (CRC is captured on PMUX RESET then COMPARE\n\
            is captured on DUT RESET, but CRC failure was detected first and its was maintained all along) Please\n\
            rerun the runtime test to check if this behavior still persists.\n",
        "not_tested"                : "Please check if the HW RESET occurred or not.\n"
    }

    global_errors_dict = {
        "hw_track_issue"            : "Some tracks are failing due to HW issue. Please source ./dont_use_tracks.rdc (or ./dont_use_tracks.tcl)\n\
            in your VPS run to omit the failing track(s).\n",
        "hw_track_issue_no_mux"     : "COMPARE is FAIL on some tracks with no PINMUX. Please note that a FAIL comparison status on a track with no\n\
            PINMUX can be interpreted as follows:\n\
                1 - A failing HW track. Please source ./dont_use_tracks.rdc (or ./dont_use_tracks.tcl) in your VPS run using to omit it.\n\
                2 - A timing violation or a DUT clock frequency too high. Try relaxing the timing constraints using the synthesis tool or\n\
                    choose a lower clock frequency.\n",
        "normal_error"              : "Some tracks are failing due to timing violations or to a DUT clock frequency too high. Try relaxing the timing\n\
            constraints using the synthesis tool or choose a clock frequency that is equal or lower than the clock frequency\n\
            computed by wrap.\n",
        "normal_error_corrected"    :"CRC check is failing on some tracks but COMPARE = OK: CRC and COMPARE status are captured on different RESET\n\
            events (CRC is captured on PMUX RESET then COMPARE is captured on DUT RESET, but CRC failure was detected\n\
            first and its was maintained all along) Please rerun the runtime test to check if this behavior still persists.\n",
        "not_tested"                : "Some tracks were not tested correctly. Please check if the HW RESET occurred or not.\n"
    }

    fpga_timing_dict = {}
    timing_violations = 0

    from_fpga_set = set()
    to_fpga_set = set()
    matched_from_fpga_set = set()
    matched_to_fpga_set = set()

    def __init__(self, redrun_log_path=None, tracks_json_path=None, from_fpga=None, to_fpga=None, runtime_folder=None):
        if not redrun_log_path:
            raise ReddiagRTException("No log file specified.")
        if not os.path.exists(redrun_log_path):
            raise ReddiagRTException("The file {} does not exist.".format(redrun_log_path))
        if not tracks_json_path:
            raise ReddiagRTException("No json file specified.")
        if not os.path.exists(tracks_json_path):
            raise ReddiagRTException("The file {} does not exist.".format(tracks_json_path))        

        self.tracks_json_path = tracks_json_path
        self.redrun_log_path = redrun_log_path
        self.from_fpga = from_fpga
        self.to_fpga = to_fpga
        self.runtime_folder = runtime_folder

        with open(self.redrun_log_path, "r") as r_redrun, open(self.tracks_json_path, "r") as r_json:
            self.tracks_data = json.loads(r_json.read())
            self.redrun_log = r_redrun.readlines()

        self.check_user_from_to()

        self.gvalue_section = self.extract(start_tag=self.gvalue_start_tag, end_tag=self.gvalue_end_tag)
        self.pmux_section = self.extract(start_tag=self.pmux_start_tag, end_tag=self.pmux_end_tag)

        self.extract_paths()
        self.extract_timing_data()
        self.extract_track_nets()
        self.extract_pmux_data()
        self.map_gnets_to_fpga()
        self.get_header_sizes()

    def extract_paths(self):
        for line in self.redrun_log:
            if line.startswith("__OUT_DIR__"):
                self.out_dir = line.split("=")[1].strip()
            if line.startswith("__COMPILE_DIR__"):
                self.compile_dir = line.split("=")[1].strip()

    def extract_timing_data(self):

        if self.compile_dir != None:
            if not os.path.exists(self.compile_dir):
                print "\033[93;1m[WARNING] Could not find compilation dir \"" + \
                    self.compile_dir + \
                    "\" to extract timing results.\033[0m"
                return

            summary_file_path = os.path.join(
                self.compile_dir, "report", "summary.rpt")
            if not os.path.exists(summary_file_path):
                print "\033[93;1m[WARNING] Could not find report/summary.rpt under " + \
                    self.compile_dir + " for timing results extraction.\033[0m"
                return

            with open(summary_file_path, "r") as r:
                spnr_section = self.extract_from_text(
                    "spnr-------", "---------", r.readlines())
                for lines in spnr_section.splitlines():
                    try:
                        line = " ".join(lines.strip().split()).split(" ")
                        fpga_name = line[0][2:].split("(")[0]
                        # print line
                        # print fpga_name
                        if line[1].startswith("Complete"):
                            self.fpga_timing_dict.update({
                                fpga_name: {
                                    "ran": 1,
                                    "clean": 1 if (float(line[-4]) >= 0 and float(line[-3]) >= 0 and float(line[-2]) >= 0 and float(line[-1]) >= 0) else 0,
                                    "WNS": float(line[-4]),
                                    "TNS": float(line[-3]),
                                    "WHS": float(line[-2]),
                                    "THS": float(line[-1])
                                }
                            })
                        else:
                            self.fpga_timing_dict.update({
                                fpga_name: {
                                    "ran": 0,
                                    "clean": 1
                                }
                            })
                    except:
                        print "\033[93;1m[WARNING] Could not extract timing data from " + \
                            summary_file_path + ".\033[0m"
        else:
            print "\033[93;1m[WARNING] Could not extract compilation directory from the current run.\033[0m"

    def extract(self, start_tag="", end_tag=""):
        extract = False
        extracted_data = ""
        for line in reversed (self.redrun_log):
            if line.startswith(start_tag): break
            if extract: extracted_data =line+extracted_data
            if line.startswith(end_tag): extract = True
        return extracted_data

    def extract_from_text(self, start_tag="", end_tag="", source=""):
        extract = False
        extracted_data = ""
        for line in source:
            if line.startswith(end_tag):
                extract = False
            if extract:
                extracted_data += line
            if line.startswith(start_tag):
                extract = True
        return extracted_data

    def format_net_value(self, net_value=""):
        if re.match(r"0x[0-9a-fA-F]{8}", net_value): #one line value
            return [net_value[2:]]
        if not re.match(r"[0-9a-fA-F_]+$", net_value):
            raise ReddiagRTException("Unexpected net value format for [{}]. Only supported formats are:\n\
\t- One 32bit hex value (example: 0xabcd1234)\n\t- A list of 32bit hex values seperated by '_' (example: 00000003_ffffffff_ffffffff)".format(net_value))
        return net_value.split("_")[::-1]

    def extract_track_nets (self):
        for line in self.gvalue_section.split("\n"):
            if not line.strip(): continue
            if (re.match('Info', line)) : continue
            net = line.strip().split("=")[0]
            net_name = ""
            net_size_str = ""
            net_value_str = ""
            net_value = []
            net_size = 0;
            try:
                net_name = net.split("[")[0].strip()
                net_size_str = net.split("[")[1].split(":")[0]
                net_size = int(net_size_str)
            except IndexError:
                net_name = net.strip()
                net_size = 1
            except ValueError:
                net_size = 1

            net_value_str = line.split("=")[1].strip()
            net_value = self.format_net_value(net_value_str)
            
            self.track_nets_dict.update({net_name: {
                "value" : net_value,
                "size": net_size}})

    def extract_pmux_data(self):
        if self.pmux_section.find(self.pmux_warning) != -1:
            return
        pmux_pattern = re.compile(r"^ .*SERDES_LOCKED: (?P<serdes_lock_status>\d).*RX_LOCKED: (?P<rx_lock_status>\d).*TRANSMISSION_ERROR: (?P<crc_error>\d|([^\s]+)).*TRACK_NAME: (?P<track_name>([^\s]+)).*$")
        for line in self.pmux_section.split("\n"):
            matches = pmux_pattern.search(line)
            if matches != None:
                self.pinmux_dict.update({matches.groupdict()['track_name']: {
                "serdes_lock_status" : matches.groupdict()['serdes_lock_status'],
                "rx_lock_status": matches.groupdict()['rx_lock_status'],
                "crc_error": matches.groupdict()['crc_error']}})

    def check_user_from_to(self):

        for fpga_pair in self.tracks_data['track_nets']:
            self.from_fpga_set.add(fpga_pair['from_fpga'])
            self.to_fpga_set.add(fpga_pair['to_fpga'])
        
        # The .+ symbol is used in place of * symbol
        # The ? symbol is used in place of . symbol
        match_str_from  = self.from_fpga.replace(".","?").replace("*",".+")
        match_str_to    = self.to_fpga.replace(".","?").replace("*",".+")
        self.matched_from_fpga_set = filter(lambda x : re.search(match_str_from,x), self.from_fpga_set)
        self.matched_to_fpga_set = filter(lambda x : re.search(match_str_to,x), self.to_fpga_set)

        if not self.matched_from_fpga_set:
            all_fpgas = '\n'.join(self.from_fpga_set)
            print("Argument -from: The string {} does not match any FPGA. Available FPGAs are :\n{}.".format(self.from_fpga,all_fpgas))
            sys.exit(1)
        if not self.matched_to_fpga_set:
            all_fpgas = '\n'.join(self.to_fpga_set)
            print("Argument -to: The string {} does not match any FPGA. Available FPGAs are :\n{}.".format(self.to_fpga,all_fpgas))
            sys.exit(1)

    def generate_report_fpga(self, from_fpga="", to_fpga=""):
        if from_fpga in self.matched_from_fpga_set and to_fpga in self.matched_to_fpga_set:
            return True
        else:
            return False

    def map_gnets_to_fpga(self):
        all_fpgas = [key["to_fpga"] for key in self.tracks_data['global_nets']]
        for fpga in all_fpgas:
            compare_net = filter(lambda x : x['to_fpga'] == fpga and x['type'] == "compare", self.tracks_data['global_nets'])[0]
            compare_n_net = filter(lambda x : x['to_fpga'] == fpga and x['type'] == "compare_n", self.tracks_data['global_nets'])[0]
            testing_net = filter(lambda x : x['to_fpga'] == fpga and x['type'] == "testing", self.tracks_data['global_nets'])[0]
            testing_n_net = filter(lambda x : x['to_fpga'] == fpga and x['type'] == "testing_n", self.tracks_data['global_nets'])[0]
            self.gnets_to_fpga_dict.update({
                fpga : {
                    "compare" : compare_net['net'],
                    "compare_n" : compare_n_net['net'],
                    "testing" : testing_net['net'],
                    "testing_n" : testing_n_net['net']
                }})

    def get_net_mask_status(self, net="", mask=0):
        if not net in self.track_nets_dict:
            raise ReddiagRTException("The net {} does not exist.".format(net))
        
        pos = mask / 32
        shift = mask % 32
        try:
            bin_data =  format(int(self.track_nets_dict[net]['value'][pos],16), '032b')[::-1]
        except (ValueError,IndexError):
            raise ReddiagRTException("Could not extract status using net = [{}], mask [{}]".format(net,mask))
        return bin_data[shift]
    
    def get_compare_status(self, combi=""):
        if combi == "1010":
            return "OK"
        elif combi[2:] == "01":
            return "NOT TESTED"
        elif combi == "0000":
            return "NOT TESTED"
        else:
            return "FAIL"
    
    def get_global_status(self, from_fpga="", to_fpga="", track_type = ""):

        compare_net = self.gnets_to_fpga_dict[to_fpga]['compare']
        # compare_n_net = self.gnets_to_fpga_dict[to_fpga]['compare_n']
        # testing_net = self.gnets_to_fpga_dict[to_fpga]['testing']
        # testing_n_net = self.gnets_to_fpga_dict[to_fpga]['testing_n']

        compare = self.get_net_mask_status(net=compare_net, mask=0)
        # compare_n = self.get_net_mask_status(net=compare_n_net, mask=0)
        # testing = self.get_net_mask_status(net=testing_net, mask=0)
        # testing_n = self.get_net_mask_status(net=testing_n_net, mask=0)

        # compare_status = self.get_compare_status(''.join((compare,compare_n,testing,testing_n)))

        tracks_filter = filter(lambda x: (x['from_fpga'] == from_fpga) and (x['to_fpga'] == to_fpga), self.tracks_data['track_nets'])
        if len(tracks_filter) != 1:
            raise ReddiagRTException("Unexpected number of tracks between {} and {}.".format(from_fpga,to_fpga))
        tracks = filter(lambda x : x["type"] == track_type, tracks_filter[0]['tracks'])

        number_of_tracks = len(tracks)

        status_dict = {
            "compare"               : "NOOO",
            "serdes_lock_status"    : "NOOO",
            "rx_lock_status"        : "NOOO",
            "crc_status"            : "NOOO"
        }

        if number_of_tracks == 0:
            return [status_dict,0]

        failing_tracks_cmp = filter(lambda x:self.get_track_status(x)['compare'] == "FAIL", tracks)

        rx_locks = []
        crc_errors = []
        serdes_locks = []

        for track in tracks:
            try:
                rx_locks.append(self.pinmux_dict[track['name']]['rx_lock_status'])
                crc_errors.append(self.pinmux_dict[track['name']]['crc_error'])
                serdes_locks.append(self.pinmux_dict[track['name']]['serdes_lock_status'])
            except KeyError:
                pass
        self.all_fpgas_set.add(to_fpga)
        if compare != "1":
            self.cmp_failed_fpga.add(to_fpga)
        status_dict.update({
            "compare"               : "{}".format(len(failing_tracks_cmp)),
            "serdes_lock_status"    : "N/A",
            "rx_lock_status"        : "N/A",
            "crc_status"            : "N/A"
        })

        if not rx_locks:
            return [status_dict,number_of_tracks]
        
        serdes_errors_count = len(filter(lambda x: x == "0" ,serdes_locks))
        rx_errors_count = len(filter(lambda x: x == "0" ,rx_locks))

        ok_crc_errors_status = len(filter(lambda x: x == '0' ,crc_errors))
        nok_crc_errors_status = len(filter(lambda x: x == '1' ,crc_errors))
        no_crc_status = len(filter(lambda x: x.startswith('NA') ,crc_errors))

        if serdes_errors_count > 0:
            self.serdes_failed_fpga.add(to_fpga)
        if rx_errors_count > 0:
            self.rx_failed_fpga.add(to_fpga)
        if nok_crc_errors_status > 0:
            self.crc_failed_fpga.add(to_fpga)

        crc_status = ""

        if no_crc_status == len(crc_errors):
            crc_status = "N/A"
        else:
            crc_status = "{}".format(nok_crc_errors_status)
        
        status_dict.update({
            "serdes_lock_status"    : "{}".format(serdes_errors_count),
            "rx_lock_status"        : "{}".format(rx_errors_count),
            "crc_status"            : crc_status})

        return [status_dict,number_of_tracks]

    def get_track_status(self, track_dict={}):
        track_name = track_dict['name']
        compare_net = track_dict['net']
        mask = track_dict['net_mask']
        compare = self.get_net_mask_status(net=compare_net, mask=mask)
        compare_status = "OK" if compare == "1" else "FAIL"

        rx_locks = ""
        crc_errors = ""
        serdes_locks = ""
        status_dict = {
            "compare"               : compare_status,
            "serdes_lock_status"    : "N/A",
            "rx_lock_status"        : "N/A",
            "crc_status"            : "N/A"}
        try:
            serdes_lock = self.pinmux_dict[track_name]['serdes_lock_status']
            rx_lock = self.pinmux_dict[track_name]['rx_lock_status']
            crc_error = self.pinmux_dict[track_name]['crc_error']

            crc_status = ""
            if crc_error == "0": crc_status = "OK"
            elif crc_error == "1": crc_status = "FAIL"
            else: crc_status = "N/A"
            status_dict.update({
                "serdes_lock_status"    : "OK" if serdes_lock == "1" else "FAIL",
                "rx_lock_status"        : "OK" if rx_lock == "1" else "FAIL",
                "crc_status"            : crc_status
                        })
        except KeyError:
            pass
        return status_dict

    def treat_suggestion(self,status):
        compare = status['compare']
        crc_status = status['crc_status']
        rx_lock_status = status['rx_lock_status']
        serdes_lock_status = status['serdes_lock_status']

        error = ""

        #identify error type
        if serdes_lock_status == "FAIL" and rx_lock_status == "FAIL" and compare == "FAIL":
            error = "hw_track_issue"
        elif serdes_lock_status == "FAIL" or rx_lock_status == "FAIL":
            error = "hw_track_issue"
        elif compare == "FAIL":
            if crc_status in ["OK", "N/A"] and rx_lock_status == "OK" and serdes_lock_status == "OK":
                error = "normal_error"
            elif crc_status == "N/A" and rx_lock_status == "N/A" and serdes_lock_status == "NA":
                error = "hw_track_issue_no_mux"
            else:
                error = "hw_track_issue"
        elif compare == "NOT TESTED":
            if crc_status in ["OK", "N/A"] and rx_lock_status in ["OK", "N/A"] and serdes_lock_status in ["OK", "N/A"]:
                error = "not_tested"
            else:
                error = "hw_track_issue"
        elif crc_status == "FAIL" and compare == "OK":
            error = "normal_error_corrected"
        
        if not error: return ""

        self.global_errors.add(error)
        
        if error not in self.errors_indexes:
            self.error_counter+=1
            self.errors_indexes.update({error:self.error_counter})
            return " ({})".format(self.error_counter)
        else:
            return " ({})".format(self.errors_indexes[error])

    def get_detailed_timing_summary(self):
        if self.fpga_timing_dict == None:
            return " -- (NOT EXTRACTED)\n\n"

        # | FPGA NAME | WNS(ns) |  TNS(ns) |  WHS(ns)  | THS(ns) |
        sizes = ['fpga', 'timing', 'timing', 'timing', 'timing']
        field_names = ['FPGA', 'WNS(ns)', 'TNS(ns)', 'WHS(ns)', 'THS(ns)']

        field_sizes = [max(self.header_sizes_dict[sizes[i]], len(
            field_names[i])) for i in range(len(sizes))]

        report = "+"
        for i in range(len(field_sizes)):
            report += "{}+".format('-'*(field_sizes[i]+2))
        # line 2
        report += "\n|"
        for i in range(len(field_sizes)):
            report += " {0:<{1}s} |".format(field_names[i], field_sizes[i])
        # line 3
        report += "\n+"
        for i in range(len(field_sizes)):
            report += "{}+".format('-'*(field_sizes[i]+2))

        report += "\n"

        for fpga in self.all_fpgas_set:

            wns, tns, whs, ths = "N/A", "N/A", "N/A", "N/A"
            try:
                if self.fpga_timing_dict[fpga]["ran"] == 1:
                    wns = str(self.fpga_timing_dict[fpga]["WNS"])
                    tns = str(self.fpga_timing_dict[fpga]["TNS"])
                    whs = str(self.fpga_timing_dict[fpga]["WHS"])
                    ths = str(self.fpga_timing_dict[fpga]["THS"])
            except KeyError:
                pass

            report += "| {0:<{fields[0]}s} | {1:<{fields[1]}s} | {2:^{fields[2]}} | {3:^{fields[3]}s} | {4:^{fields[4]}s} |\n".format(
                fpga, wns, tns, whs, ths, fields=field_sizes)

        report += "+"
        for i in range(len(field_sizes)):
            report += "{}+".format('-'*(field_sizes[i]+2))
        report += "\n\n"
        return report

    def get_header_sizes(self):
        self.header_sizes_dict.update({
            "fpga" : max(map(lambda x: len(x['to_fpga']), self.tracks_data['global_nets'])),
            "net"  : max(map(lambda x: len(x['net']), self.tracks_data['global_nets'])),
            "conn" : max(map(lambda x: max([len(track['drv_conn']) for track in x['tracks']]), self.tracks_data['track_nets'])),
            "name" : max(map(lambda x: max([len(track['name']) for track in x['tracks']]), self.tracks_data['track_nets'])),
            "type" : max(map(lambda x: max([len(track['type']) for track in x['tracks']]), self.tracks_data['track_nets'])),
            "pin"  : max(map(lambda x: max([len(track['drv_pin']) for track in x['tracks']]), self.tracks_data['track_nets'])),
            "bank"  : 3,
            "serdes_lock" : 3,
            "rx_lock"     : 3,
            "crc"         : 3,
            "compare_testing"   : 3,
            "num_tracks"  : 6,
            "reports_path" : max(map(lambda x: len(x['to_fpga']), self.tracks_data['global_nets']))*2 + len(" to_track_report.rpt "),
            "timing" : 7
            })
    
    def get_global_summary(self):

        sizes = ['fpga','fpga', 'num_tracks', 'serdes_lock', 'rx_lock', 'crc', 'compare_testing', 'reports_path']
        field_names = ['From FPGA', 'To FPGA', 'TOTAL TRACKS', 'SERDES LOCK FAILS', 'RX LOCK FAILS', 'CRC FAILS', 'COMPARE FAILS', 'REPORTS PATH']
        if len(sizes) != len(field_names):
            raise ReddiagRTException("Printing header: sizes and field names are different")
        
        field_sizes = [max(self.header_sizes_dict[sizes[i]], len(field_names[i])) for i in range(len(sizes))]

        track_types = ["transceiver", "diff", "single_ended", "dib"]

        report = ""
        all_tracks = self.tracks_data["track_nets"]
        section = 1
        for track_type in track_types:
            has_track_type = False
            for i in all_tracks:
                tracks_filter = filter(lambda x: x["type"] == track_type,i["tracks"])
                # print len(tracks_filter)
                if len(tracks_filter) != 0:
                    has_track_type = True
            if not has_track_type:
                continue
            #line 1

            report+= "------------------------------------------------------------------------\n"
            if track_type == "transceiver":
                report+= "-- 2.{}: Transceiver Tracks Global Status\n".format(section)
                section+=1
                self.sub_sections.append("Transceiver")
            elif track_type == "diff":
                report+= "-- 2.{}: Differential Tracks Global Status\n".format(section)
                section+=1
                self.sub_sections.append("Differential")
            elif track_type == "single_ended":
                report+= "-- 2.{}: Single-Ended Tracks Global Status\n".format(section)
                section+=1
                self.sub_sections.append("Single-Ended")
            elif track_type == "dib":
                report+= "-- 2.{}: DIB Tracks Global Status\n".format(section)
                section+=1
                self.sub_sections.append("DIB")           
            report+= "------------------------------------------------------------------------\n"
            report+="+"
            for i in range(len(field_sizes)):
                report+="{}+".format('-'*(field_sizes[i]+2))
            #line 2
            report+="\n|"
            for i in range(len(field_sizes)):
                report+=" {0:<{1}s} |".format(field_names[i], field_sizes[i])
            #line 3
            report+="\n+"
            for i in range(len(field_sizes)):
                report+="{}+".format('-'*(field_sizes[i]+2))

            report += "\n"
            for fpga_pair in self.tracks_data['track_nets']:
                from_fpga = fpga_pair['from_fpga']
                to_fpga = fpga_pair['to_fpga']
                
                status,total = self.get_global_status(from_fpga=from_fpga, to_fpga=to_fpga, track_type=track_type)

                if total:
                    track_report = "-"
                    if self.generate_report_fpga(from_fpga,to_fpga):
                        track_report = "{}_to_{}_track_report.rpt".format(from_fpga,to_fpga)

                    report+="| {0:<{fields[0]}s} | {1:<{fields[1]}s} | {2:^{fields[2]}} | {3:^{fields[3]}s} | {4:^{fields[4]}s} | {5:^{fields[5]}s} | {6:^{fields[6]}} | {7:<{fields[7]}s} |".format(
                        from_fpga, to_fpga,total, status['serdes_lock_status'], status['rx_lock_status'], status['crc_status'], status['compare'],
                        track_report, fields = field_sizes)
                    report+="\n"

            report+="+"
            for i in range(len(field_sizes)):
                report+="{}+".format('-'*(field_sizes[i]+2))
            report +="\n"
            report +="\n"
         
        summary = "GLOBAL SUMMARY:\n\n"

        summary += "        FPGAS WITH TIMING ISSUES       : "
        if self.fpga_timing_dict != {}:
            fpgas_with_issues = ""
            for key, value in self.fpga_timing_dict.items():
                if value["clean"] == 0:
                    self.timing_violations += 1
                    if self.timing_violations == 1:
                        fpgas_with_issues += key
                    else:
                        fpgas_with_issues += ", " + key

            summary += "{}{}{}{}\n".format(self.timing_violations, " (" if fpgas_with_issues != None else " ",
                                           fpgas_with_issues, ")" if fpgas_with_issues != None else "",)
        else:
            summary += "N/A\n"

        summary += "        FPGAS WITH SERDES LOCK ERRORS  : {} (*)\n".format(
            len(self.serdes_failed_fpga))
        summary += "        FPGAS WITH RX LOCK ERRORS      : {} (*)\n".format(
            len(self.rx_failed_fpga))
        summary += "        FPGAS WITH CRC ERRORS          : {} (*)\n".format(
            len(self.crc_failed_fpga))

        note = ""
        if len(self.cmp_failed_fpga) > 0:
            note += " (**)\n\n(*)  Extracted from redrun\n(**) FPGA COMPARE ERRORS are reported for each FPGA that receives signals ({} RX FPGAs in total).\n\
    For detailed status per FPGA pair, check the table below and Section 2 (Track Summary per FPGA Pair)\n".format(len(self.all_fpgas_set))
        else:
            note += "\n\n(*)  Extracted from redrun\n\n"
        summary+= "        FPGAS WITH COMPARE ERRORS      : {}{}\n".format(len(self.cmp_failed_fpga),note)

        return report, summary

    def get_global_track_status(self):

        TRACK_SORT_ORDER = {
            "transceiver"   : 0,
            "diff"          : 1,
            "single_ended"  : 2,
            "dib"           : 3}
        def track_sort(e):
            return TRACK_SORT_ORDER[e['type']]
        
        global_status = ""
        for fpga_pair in self.tracks_data['track_nets']:
            from_fpga = fpga_pair['from_fpga']
            to_fpga = fpga_pair['to_fpga']
            track_report_file = os.path.join(self.runtime_folder, self.reddiag_reports_folder, "{}_to_{}_track_report.rpt".format(from_fpga,to_fpga))

            transceiver_tracks = filter(lambda x: x['type'] == 'transceiver', fpga_pair['tracks'])
            diff_tracks = filter(lambda x: x['type'] == 'diff', fpga_pair['tracks'])
            se_tracks = filter(lambda x: x['type'] == 'single_ended', fpga_pair['tracks'])
            dib_tracks = filter(lambda x: x['type'] == 'dib', fpga_pair['tracks'])

            sizes = ['name','pin','pin','bank','bank','conn','conn','serdes_lock', 'rx_lock', 'crc', 'compare_testing']         
            field_names = ['TRACK NAME', 'DRV PIN','RCV PIN','DRV BANK','RCV BANK','DRV CONN', 'RCV CONN','SERDES LOCK', 'RX LOCK', 'CRC Status ', 'Compare Status']
            report = ""
            sections = 1
            if len(sizes) != len(field_names):
                raise ReddiagRTException("Printing header: sizes and field names are different")
            field_sizes = [max(self.header_sizes_dict[sizes[i]], len(field_names[i])) for i in range(len(sizes))]
            report+= "FILE: {}\n".format(os.path.basename(track_report_file))
            report+= "-"*(len(os.path.basename(track_report_file))+7)+"\n\n"
            report+= "========================================================================\n"
            report+= "========================== Table Of Contents ===========================\n"
            report+= "========================================================================\n"
            if transceiver_tracks:
                report+= "-- Section {} : Transceiver Tracks Status\n".format(sections)
                sections+=1
            if diff_tracks:
                report+= "-- Section {} : Differential Tracks Status\n".format(sections)
                sections+=1
            if se_tracks:
                report+= "-- Section {} : Single-Ended Tracks Status\n".format(sections)
                sections+=1
            if dib_tracks:
                report+= "-- Section {} : DIB Tracks Status\n".format(sections)
                sections+=1
            report+= "========================================================================\n\n\n"
            all_tracks = (transceiver_tracks,diff_tracks,se_tracks,dib_tracks)
            sections = 1
            all_tracks_errors = [0,0,0,0]
            all_tracks_errors_seperated = [0,0,0,0]
            track_report = ""
            all_tracks_report = ""
            serdes_or_rx_lock_failing_tracks = []
            se_compare_failing_tracks = []
            diff_transmission_error_or_compare_failing_tracks = []
            for i in range(len(all_tracks)):
                if not all_tracks[i]:
                    continue
                track_type = ["Transceiver", "Differential", "Singe-Ended", "DIB"][i]
                report+= "========================================================================\n"
                report+= "-- Section {} : {} Tracks Status\n".format(sections, track_type)
                report+= "========================================================================\n\n"
                sections+=1
                summary = ""
                summary+= "{} Tracks Summary:\n".format(track_type)
                summary+= "-------------------------------------\n"

                #line 1
                track_report= "+"
                for j in range(len(field_sizes)):
                    track_report+= "{}+".format('-'*(field_sizes[j]+2))
                #line 2
                track_report+="\n|"
                for j in range(len(field_sizes)):
                    track_report+= " {0:<{1}s} |".format(field_names[j], field_sizes[j])
                #line 3
                track_report+="\n+"
                for j in range(len(field_sizes)):
                    track_report+= "{}+".format('-'*(field_sizes[j]+2))
                track_report += "\n"

                compares = 0
                rx_locks = 0
                serdes_locks = 0
                crc_errors = 0
                for track in all_tracks[i]:
                    status = self.get_track_status(track_dict=track)
                    suggestion = self.treat_suggestion(status)
                    if status['compare'] == "FAIL":
                        compares += 1
                    if status['rx_lock_status'] == "FAIL":
                        rx_locks += 1
                    if status['serdes_lock_status'] == "FAIL":
                        serdes_locks += 1
                    if status['crc_status'] == "FAIL":
                        crc_errors += 1

                    if status['rx_lock_status'] == "FAIL" or status['serdes_lock_status'] == "FAIL":
                        serdes_or_rx_lock_failing_tracks.append(track)
                    elif status['rx_lock_status'] == "N/A" and status['serdes_lock_status'] == "N/A" and status['compare'] == "FAIL":
                        se_compare_failing_tracks.append(track)
                    elif status['crc_status'] == "FAIL" or status['compare'] == "FAIL" :
                        diff_transmission_error_or_compare_failing_tracks.append(track)

                    track_report+="\
| {0:<{fields[0]}s} | {1:^{fields[1]}s} | {2:^{fields[2]}s} | {3:^{fields[3]}} | {4:^{fields[4]}} |\
 {5:^{fields[5]}s} | {6:^{fields[6]}s} | {7:^{fields[7]}s} | {8:^{fields[8]}s} | {9:^{fields[9]}s} | {10:^{fields[10]}s} | {11}".format(
                        track['name'],
                        track['drv_pin'],
                        track['rcv_pin'],
                        track['drv_bank_id'],
                        track['rcv_bank_id'],
                        track['drv_conn'],
                        track['rcv_conn'],
                        status['serdes_lock_status'],
                        status['rx_lock_status'],
                        status['crc_status'],
                        status['compare'],
                        suggestion,
                        fields = field_sizes)
                    track_report+= "\n+"
                    for j in range(len(field_sizes)):
                        track_report+= "{}+".format('-'*(field_sizes[j]+2))
                    track_report += "\n"

                all_tracks_errors[i] = compares+rx_locks+serdes_locks+crc_errors
                all_tracks_errors_seperated[i] = [serdes_locks,rx_locks,crc_errors,compares]
                summary+= "        TOTAL TRACKS             : {}\n".format(len(all_tracks[i]))
                summary+= "        SERDES LOCK ERRORS       : {}\n".format(serdes_locks)
                summary+= "        RX LOCK ERRORS           : {}\n".format(rx_locks)
                summary+= "        CRC ERRORS               : {}\n".format(crc_errors)
                summary+= "        TRACK COMPARE ERRORS     : {}\n\n".format(compares)

                report+=summary
                report+=track_report

                suggestions = ""
                if self.errors_indexes:
                    suggestions += "\n"
                    try:
                        sorted_errors = sorted(self.errors_indexes.items(), key=lambda x:x[1])
                        for error in sorted_errors:
                            suggestions += "    ({}) {}".format(error[1],self.track_errors_dict[error[0]])
                    except KeyError:
                        pass
                    self.errors_indexes = {}
                    self.error_counter = 0
                report+=suggestions
                report+= "\n========================================================================\n"
            if os.path.exists(track_report_file):
                raise ReddiagRTException("Cannot generate {}. Reason: File already exists".format(track_report_file))
            if self.generate_report_fpga(from_fpga,to_fpga):
                with open(track_report_file, "w") as w:
                    w.write(report)

            if serdes_or_rx_lock_failing_tracks or se_compare_failing_tracks or diff_transmission_error_or_compare_failing_tracks:
                self.generate_failing_tracks(from_fpga=from_fpga,to_fpga=to_fpga,tracks=[serdes_or_rx_lock_failing_tracks,se_compare_failing_tracks,diff_transmission_error_or_compare_failing_tracks])

        return global_status

    def generate_failing_tracks(self,from_fpga="",to_fpga="",tracks=[]):
        if not self.generate_report_fpga(from_fpga,to_fpga):
            return
        dont_use_track_file_tcl = os.path.join(self.runtime_folder, self.reddiag_reports_folder, 'dont_use_tracks.tcl')
        dont_use_track_file_rdc = os.path.join(self.runtime_folder, self.reddiag_reports_folder, 'dont_use_tracks.rdc')
        dont_use_text_tcl = ""
        dont_use_text_rdc = ""
        if tracks[0]:
            dont_use_text_tcl += "\n# NOTE: The following tracks are failing due to pinmux rx lock error or serdes lock error.\n"
            dont_use_text_rdc += "\n# NOTE: The following tracks are failing due to pinmux rx lock error or serdes lock error.\n"
            for track in tracks[0]:
                conn_info = "" if track['drv_conn'] == "None" else "CONN: {}->{}    ".format(track['drv_conn'],track['rcv_conn'])
                dont_use_text_tcl += "route set_track {} -dont_use  ;# TYPE:{}    {}BANK: {}->{}    PIN: {}->{}\n".format(track['name'],
                    track['type'].upper(), conn_info, track['drv_bank_id'], track['rcv_bank_id'],track['drv_pin'],track['rcv_pin'])
                if track['dual'] != "None" : dont_use_text_tcl += "route set_track {} -dont_use  ;# Dual of track : {}\n".format(track['dual'],track['name'])
                dont_use_text_rdc += "set_property DONT_USE TRUE [ get_hw_tracks {} ]  ;# TYPE:{}    {}BANK: {}->{}    PIN: {}->{}\n".format(track['name'],
                    track['type'].upper(), conn_info, track['drv_bank_id'], track['rcv_bank_id'],track['drv_pin'],track['rcv_pin'])
                if track['dual'] != "None" : dont_use_text_rdc += "set_property DONT_USE TRUE [ get_hw_tracks {} ]  ;# Dual of track : {}\n".format(track['dual'],track['name'])
        if tracks[1]:
            dont_use_text_tcl += "\n# NOTE: The status of the following tracks was only deduced from DUT comparison (NO PINMUX).\n"
            dont_use_text_rdc += "\n# NOTE: The status of the following tracks was only deduced from DUT comparison (NO PINMUX).\n"
            for track in tracks[1]:
                conn_info = "" if track['drv_conn'] == "None" else "CONN: {}->{}    ".format(track['drv_conn'],track['rcv_conn'])
                dont_use_text_tcl += "route set_track {} -dont_use  ;# TYPE:{}    {}BANK: {}->{}    PIN: {}->{}\n".format(track['name'],
                    track['type'].upper(), conn_info, track['drv_bank_id'], track['rcv_bank_id'],track['drv_pin'],track['rcv_pin'])
                dont_use_text_rdc += "set_property DONT_USE TRUE [ get_hw_tracks {} ]  ;# TYPE:{}    {}BANK: {}->{}    PIN: {}->{}\n".format(track['name'],
                    track['type'].upper(), conn_info, track['drv_bank_id'], track['rcv_bank_id'],track['drv_pin'],track['rcv_pin'])
        if tracks[2]:
            dont_use_text_tcl += "\n# NOTE: The following tracks are failing due to pinmux transmission error or compare fail.\n"
            dont_use_text_rdc += "\n# NOTE: The following tracks are failing due to pinmux transmission error or compare fail.\n"
            for track in tracks[2]:
                conn_info = "" if track['drv_conn'] == "None" else "CONN: {}->{}    ".format(track['drv_conn'],track['rcv_conn'])
                dont_use_text_tcl += "route set_track {} -dont_use  ;# TYPE:{}    {}BANK: {}->{}    PIN: {}->{}\n".format(track['name'],
                    track['type'].upper(), conn_info, track['drv_bank_id'], track['rcv_bank_id'],track['drv_pin'],track['rcv_pin'])
                if track['dual'] != "None" : dont_use_text_tcl += "route set_track {} -dont_use  ;# Dual of track : {}\n".format(track['dual'],track['name'])
                dont_use_text_rdc += "set_property DONT_USE TRUE [ get_hw_tracks {} ]  ;# TYPE:{}    {}BANK: {}->{}    PIN: {}->{}\n".format(track['name'],
                    track['type'].upper(), conn_info, track['drv_bank_id'], track['rcv_bank_id'],track['drv_pin'],track['rcv_pin'])
                if track['dual'] != "None" : dont_use_text_rdc += "set_property DONT_USE TRUE [ get_hw_tracks {} ]  ;# Dual of track : {}\n".format(track['dual'],track['name'])


        with open(dont_use_track_file_tcl, "a+") as w_tcl, open(dont_use_track_file_rdc, "a+") as w_rdc:
            w_tcl.write('\n\n')
            w_rdc.write('\n\n')
            head = '##################################################################\n'
            head += '## {} --> {}\n##################################################################\n'.format(from_fpga,to_fpga)
            w_tcl.write(head)
            w_rdc.write(head)
            w_tcl.write(dont_use_text_tcl)
            w_rdc.write(dont_use_text_rdc)
            w_tcl.write('\n')
            w_rdc.write('\n')


    def generate_full_report(self):
        status = True
        sumary_file_path = os.path.join(self.runtime_folder, self.reddiag_reports_folder,self.track_summary)
        if os.path.exists(sumary_file_path):
            raise ReddiagRTException("Cannot generate {}. Reason: File already exists").format(sumary_file_path)
        summary = ""
        head = ""
        section1 = ""
        section2 = ""

        report,glob_summary = self.get_global_summary();

        head+= "EXTRACTED FROM {}\n".format(self.redrun_log_path)
        head+= "------------------------------------------------------------------------\n\n"
        head+= "========================================================================\n"
        head+= "========================== Table Of Contents ===========================\n"
        head+= "========================================================================\n"
        head+= "-- Section 1 : Hardware Global Status\n"
        head+= "-- Section 2 : Track Summary per Type\n"
        for i in range(len(self.sub_sections)):
            head+= "  - 2.{} : {} Tracks Global Status\n".format(i+1,self.sub_sections[i])
        head += "-- Section 3 : Timing Summary\n"
        head += "-- Section 4 : Detected Failures Summary\n"
        head += "========================================================================\n\n\n"

        section1+= "========================================================================\n"
        section1+= "-- Section 1 : Hardware Global Status\n"
        section1+= "========================================================================\n\n"
        section1+= glob_summary
        section1+= "========================================================================\n\n"

        section2+= "========================================================================\n"
        section2+= "-- Section 2 : Track Status Summary per Type\n"
        section2+= "========================================================================\n\n"
        section2+= report
        section2+= self.get_global_track_status()
        section2+= "========================================================================\n\n"

        section2 += "========================================================================\n"
        section2 += "-- Section 3 : Timing Summary\n"
        section2 += "========================================================================\n\n"
        section2 += self.get_detailed_timing_summary()
        section2 += "========================================================================\n\n"

        section2 += "========================================================================\n"
        section2 += "-- Section 4 : Detected Failures Summary\n"
        section2 += "========================================================================\n\n"
        section2+= "-----------------------------------------------------------------------------------------------------------------------\n"
        section2 += "\nDETECTED FAILURES SUMMARY:\n\n"
        if self.global_errors:
            status = False
            try:
                for error in self.global_errors:
                    section2 += "    - {}".format(self.global_errors_dict[error])
            except KeyError:
                pass
            section2 += "\n"
        else:
            section2 += "    (NONE)\n\n"
        section2+= "-----------------------------------------------------------------------------------------------------------------------\n"
        summary = head+section1+section2

        with open(sumary_file_path, "w") as w:
            w.write(summary)
        return status

def epilog(script_name):
    return """
    Examples
    ========
    Generate tracks report for all FPGAs using the redrun log under redrt.out and the track list track_nets.json:
        ./""" + script_name + """ -l redrt.out -t track_nets.json
        ./""" + script_name + """ --log_dir redrt.out --tracks_list track_nets.json
        
    Generate report for tracks driven by FPGA_A and received by FPGA_B:
        ./""" + script_name + """ -log_dir redrt.out -tracks_list track_nets.json -from FPGA_A -to FPGA_TO
        ./""" + script_name + """ -log_dir redrt.out -tracks_list track_nets.json --from_fpga FPGA_A --to_fpga FPGA_B
    
    To match all FPGAs:
        ./""" + script_name + """ -log_dir redrt.out -tracks_list track_nets.json -from \* -to \*
    """

if __name__ == '__main__':

    script_name = os.path.basename(__file__)
    parser = argparse.ArgumentParser(description='Tracks report generator',
                                        formatter_class=argparse.RawDescriptionHelpFormatter,
                                        epilog=epilog(script_name))
    parser.add_argument('-l', '--log_dir', required=True, help='Redrun output directory path')
    parser.add_argument('-t', '--tracks_list', required=True, help='Tracks list file (generated by reddiag)')
    parser.add_argument('-from', '--from_fpga', default="*", help='Generate tracks report for all tracks driven by [-from FPGA] (Wildcards * and ? are supported)')
    parser.add_argument('-to', '--to_fpga', default="*", help='Generate tracks report for all tracks driving [-to FPGA] (Wildcards * and ? are supported)')
    args = parser.parse_args()

    redrun_out = args.log_dir
    json_file = args.tracks_list
    from_fpga = args.from_fpga
    to_fpga = args.to_fpga
    if not os.path.exists(redrun_out):
        print "Error: The folder {} does not exist.".format(redrun_out)
        sys.exit(1)
    files = filter(lambda x : x.startswith("redrun") and x.endswith(".log") and x.find("trace") == -1, os.listdir(os.path.join(redrun_out, "redrun/reports")))
    log_file = ""
    try:
        log_file = os.path.join(redrun_out,'redrun/reports',files[len(files)-1])
    except IndexError:
        print "Error: Could not locate the log file generated by redrun under {}.".format(os.path.join(redrun_out,"redrun/reports"))
        sys.exit(1)
    if not os.path.exists(json_file):
        print "Error: The file {} does not exist.".format(json_file)
        sys.exit(1)
    if os.path.basename(redrun_out) != "redrt.out":
        runtime_reports_dir = os.path.basename(redrun_out) + ".runtime_reports"
    else:
        runtime_reports_dir = "./runtime_reports"
    output_dir = "track_status"
    full_path = os.path.join(runtime_reports_dir, output_dir)
    full_path_previous = os.path.join(runtime_reports_dir, output_dir+".previous")
    if os.path.exists(runtime_reports_dir):
        if os.path.exists(full_path_previous):
            try:
                shutil.rmtree(full_path_previous)
            except Exception as e:
                print "Could not remove the folder {}. Reason: {}".format(full_path_previous,e)
                sys.exit(1)
        if os.path.exists(full_path):
            try:
                os.rename(full_path, full_path_previous)
            except Exception as e:
                print "Could not rename the folder {} to {}. Reason: {}".format(full_path, full_path_previous,e)
                sys.exit(1)
        try:
            os.mkdir(full_path)
        except Exception as e:
            print "Could not create folder {}. Reason: {}".format(full_path, e)
            sys.exit(1)
    else:
        try:
            os.makedirs(full_path)
        except Exception as e:
            print "Could not create folder {}. Reason: {}".format(full_path, e)
            sys.exit(1)
    
    print "Extracting track status from {}..".format(log_file)
    rtest = ReddiagRuntimeTests(redrun_log_path=log_file, tracks_json_path=json_file, from_fpga=from_fpga, to_fpga=to_fpga, runtime_folder=runtime_reports_dir)
    if not rtest.generate_full_report():
        print "\033[91;1m[FAIL] Some failures were detected while running runtime test, please check the generated report under " + runtime_reports_dir + "/track_status for details.\033[0m"
        sys.exit(1)
    else:
        print "\033[92;1m[PASS] Successfully generated track reports under " + runtime_reports_dir + "/track_status\033[0m"