# Unpublished work. Copyright 2022 Siemens                         
# This material contains trade secrets or otherwise                
# confidential information owned by Siemens Industry Software Inc. 
# or its affiliates (collectively, "SISW"), or its licensors.      
# Access to and use of this information is strictly limited as     
# set forth in the Customer's applicable agreements with SISW.     
# This file was generated by profpga_brdgen version 14.0 
#   on Fri Dec 15 16:10:03 2023 


# Check if PROFPGA environment variable is set
if {![info exists env(PROFPGA)]} {
  error "PROFPGA environment variable is not set - please check your proFPGA software installation"
}
set PROFPGA $env(PROFPGA)

# Source pd_muxdemux and dbst tool box
source "${PROFPGA}/hdl/pd_muxdemux2/pd_muxdemux_vivado.tcl"
source "${PROFPGA}/hdl/dbst/dbst_vivado.tcl"
    
# Parameter
set TOPLEVEL "top_fpga_mb1FA1"
set PART "xcvu19p-fsva3824-2-e"
enable_beta_device


# Initialize source file arrays
set VERILOG_INC_DIRS ""
set VERILOG_SRCS ""
set VHDL_SRCS ""
set NDF_SRCS ""
set XDC_SRCS ""

# Default Verilog include directories
lappend VERILOG_INC_DIRS "${PROFPGA}/hdl/generic_hdl"
lappend VERILOG_INC_DIRS "${PROFPGA}/hdl/mmi64"
lappend VERILOG_INC_DIRS "${PROFPGA}/hdl/profpga"

# Default Verilog source files required for each FPGA
lappend VERILOG_SRCS "${PROFPGA}/hdl/generic_hdl/afifo_core.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/generic_hdl/ethernet_crc.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/generic_hdl/generic_dpram.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/generic_hdl/generic_dpram_separated_ports.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/generic_hdl/timer.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_async_buffer.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_axi_master.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_buffer_uni.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_buffer.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_identify.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_deserializer.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_m_devzero.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_m_regif.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_p_muxdemux_mux.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_p_muxdemux_demux.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_p_muxdemux_ctrl_fsm.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_p_muxdemux.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_regfifo.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_router_upstream.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_router_core.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_router.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_rt.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/mmi64/mmi64_serializer.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/profpga_user/profpga_sync_ipad.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/profpga_user/profpga_sync_opad.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/profpga_user/profpga_sync_rx.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/profpga_user/profpga_sync_tx.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/profpga_user/profpga_sync_rx2.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/profpga_user/profpga_clocksync.v"
lappend VERILOG_SRCS "${PROFPGA}/hdl/profpga_user/profpga_ctrl.v"

# Default VHDL source files required for each FPGA
lappend VHDL_SRCS "${PROFPGA}/hdl/mmi64/BitSlipInLogic_4b.vhd"
lappend VHDL_SRCS "${PROFPGA}/hdl/mmi64/BitSlipInLogic_8b.vhd"
lappend VHDL_SRCS "${PROFPGA}/hdl/mmi64/BitSlipInLogic.vhd"


# Sources specific to pd_muxdemux2
lappend VERILOG_INC_DIRS "${PROFPGA}/hdl/pd_muxdemux2"
lappend VERILOG_SRCS "${PROFPGA}/hdl/pd_muxdemux2/pd_muxdemux_xultrascale.sv"
lappend VERILOG_SRCS "${PROFPGA}/hdl/pd_muxdemux2/pd_muxdemux_bb.sv"
lappend VERILOG_SRCS "${PROFPGA}/hdl/pd_muxdemux2/pd_muxdemux.sv"

# Sources specific to the design based selftest
lappend VERILOG_INC_DIRS "${PROFPGA}/hdl/dbst"
lappend VERILOG_SRCS "${PROFPGA}/hdl/dbst/frequency_measurement.sv"
lappend VERILOG_SRCS "${PROFPGA}/hdl/dbst/pattern_generator.sv"
lappend VERILOG_SRCS "${PROFPGA}/hdl/dbst/pattern_checker.sv"
lappend VERILOG_SRCS "${PROFPGA}/hdl/dbst/dbst.sv"

# Top level file
lappend VERILOG_INC_DIRS .
lappend VERILOG_SRCS "top_fpga.sv"

# Constraints files
lappend XDC_SRCS "top_fpga.xdc"

# read in verilog files if list of files is not empty
if {[llength $VERILOG_SRCS]} {
    read_verilog -sv $VERILOG_SRCS
}

# read in vhdl files if list of files is not empty
if {[llength $VHDL_SRCS]} {
    read_vhdl $VHDL_SRCS
}

# read ip cores
foreach item $NDF_SRCS {
    read_edif $item
}

# define timing and pin constraints
foreach item $XDC_SRCS {
  read_xdc $item
}

#
## synthesis
#

# synthesize design
synth_design -top ${TOPLEVEL}  \
    -keep_equivalent_registers \
    -include_dirs $VERILOG_INC_DIRS \
    -part $PART

# write design after synthesis
write_checkpoint -force top_fpga_synthesized.dcp

# constrain pd_muxdemux and dbst
PDMuxDemux_Constrain Ultrascale AsyncMuxSysSyncClk
DBST_Constrain Ultrascale AsyncMuxSysSyncClk

# write design after pd_muxdemux_constraining
write_checkpoint -force top_fpga_synthesized_pdmuxdemux.dcp

# optimize the designdesign and write snapshot
opt_design

# write out design after optimization
write_checkpoint -force top_fpga_optimized.dcp

# run drc
report_drc -fail_on error -file top_fpga_drc_optimized.rpt

#
## placement
#

# perform placement of design
place_design 

# generate report 
catch { report_io                    -file top_fpga_io_placed.rpt }
catch { report_clock_utilization     -file top_fpga_clock_utilization_placed.rpt }
catch { report_utilization           -file top_fpga_utilization_placed.rpt }
catch { report_control_sets -verbose -file top_fpga_control_sets_placed.rpt }

# Optionally run optimization if there are timing violations after placement
if {[get_property SLACK [get_timing_paths -max_paths 1 -nworst 1 -setup]] < 0} {
  puts "Found setup timing violations => running physical optimization"
  phys_opt_design
}

#
## routing
#

# route the design
route_design

# write out design after routing
write_checkpoint -force top_fpga_routed.dcp

# generate report 
catch { report_drc            -file top_fpga_drc_routed.rpt }
#catch { report_power          -file top_fpga_power_routed.rpt }
catch { report_route_status   -file top_fpga_route_status_routed.rpt }
catch { report_timing_summary -file top_fpga_timing_summary_routed.rpt }

# bitstream settings
set_property BITSTREAM.CONFIG.UNUSEDPIN Pullnone [current_design]
set_property BITSTREAM.CONFIG.PERSIST no [current_design]
set_property BITSTREAM.STARTUP.MATCH_CYCLE Auto [current_design]
set_property BITSTREAM.GENERAL.COMPRESS True [current_design]

write_bitstream -force top_fpga.bit
